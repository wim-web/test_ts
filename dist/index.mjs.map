{"version":3,"sources":["../src/log.ts","../src/util/function.ts","../src/scheduler/index.ts","../src/timing/concrete/file.ts","../src/timing/concrete/redis.ts","../src/timing/concrete/constraint.ts"],"sourcesContent":["import { createLogger, format, transports } from \"winston\";\n\nexport let logger = createLogger({\n    transports: [\n        new transports.Console({\n            silent: true\n        })\n    ]\n})\n\nexport const enableLog = (level: string) => {\n    logger = createLogger({\n        level,\n        format: format.combine(\n            format.timestamp(),\n            format.json(),\n        ),\n        transports: [\n            new transports.Console()\n        ]\n    })\n}\n","export type SleepInput = {\n    h?: number,\n    m?: number,\n    s?: number,\n    ms?: number,\n}\n\nexport function calculateMilliseconds({\n    h, m, s, ms,\n}: SleepInput): number {\n    const toM = (h: number) => h * 60\n    const toS = (m: number) => m * 60\n    const toMS = (s: number) => s * 1000\n\n    return toMS(\n        toS(\n            toM(\n                h || 0\n            ) + (m || 0)\n        ) + (s || 0)\n    ) + (ms || 0)\n}\n\n","import { logger } from \"@/log\"\nimport { TimeConstraint, Timing } from \"@/timing/contract\"\nimport { calculateMilliseconds } from \"@/util/function\"\nimport { setTimeout } from \"timers/promises\"\n\ntype Mode = (ShotMode | LoopMode) & { _type: string }\n\ntype ShotMode = {\n    _type: \"shot\"\n}\n\ntype LoopMode = {\n    _type: \"loop\"\n    oneCycleTime: { h: number, m: number }\n}\n\nexport class Scheduler {\n    constructor(\n        private readonly mode: Mode,\n        private readonly timing: Timing,\n        private readonly tasks: Task[],\n    ) { }\n\n    async run() {\n        logger.debug(`run`, { mode: this.mode._type })\n        switch (this.mode._type) {\n            case 'shot':\n                await this.oneCycle()\n                break\n            case 'loop':\n                await this.loop(this.mode.oneCycleTime)\n                break\n        }\n    }\n\n    private async oneCycle() {\n        for (const task of this.tasks) {\n            logger.info(`start ${task.name}`, { task_name: task.name })\n            try {\n                const input = {\n                    key: task.name,\n                    date: new Date(),\n                }\n\n                if (!await this.timing.allow(input)) {\n                    continue\n                }\n\n                await task.fn()\n                await this.timing.complete({\n                    ...input,\n                    constraint: task.constraint\n                })\n                logger.info(`end ${task.name}`, { task_name: task.name })\n            } catch (e) {\n                //\n            }\n        }\n    }\n\n    private async loop(oneCycleTime: { h: number, m: number }) {\n        // ループの最低時間\n        const totalSleepMs = calculateMilliseconds(oneCycleTime);\n        let running = true\n        const controller = new AbortController();\n\n        const signalHandle = () => {\n            running = false;  // ループを停止する\n            controller.abort(); // sleepを中断\n        }\n\n        process.on('SIGINT', () => {\n            signalHandle()\n        });\n        process.on('SIGTERM', () => {\n            signalHandle()\n        });\n        process.on('SIGQUIT', () => {\n            signalHandle()\n        });\n\n        try {\n            while (running) {\n                // スタート時刻を計測\n                const startTime = Date.now()\n                logger.debug(\"start oneCycle\")\n\n                await this.oneCycle()\n\n                const endTime = Date.now()\n                logger.debug(\"end oneCycle\")\n                const elapsedTime = endTime - startTime // 処理にかかった時間を計測\n\n                // 残り時間の計算\n                const remainingSleepTime = totalSleepMs - elapsedTime\n\n                if (remainingSleepTime > 0 && running) {\n                    logger.debug(\"sleep\", { sleep_time_ms: remainingSleepTime, sleep_time_s: remainingSleepTime / 1000, sleep_time_m: remainingSleepTime / (1000 * 60) })\n                    await setTimeout(remainingSleepTime, null, { signal: controller.signal }) // 残り時間をスリープ\n                }\n            }\n        } catch (e) {\n            if (e instanceof Error && e.name === \"AbortError\") {\n                logger.info(\"\", e)\n                // 正常なのでスルー\n                logger.debug(\"stopping\")\n            } else {\n                throw e\n            }\n        }\n    }\n}\n\ntype Task = {\n    name: string,\n    constraint: TimeConstraint,\n    fn: () => Promise<void>\n}\n","import { TimeConstraint, Timing } from \"../contract\";\nimport fs from 'fs';\nimport * as path from 'path';\n\ntype Locker = {\n    [key: string]: string // 本当はvalueはdateだが、全部parseしてdateにするのは非効率なのでstringで保持する\n}\n\nexport class FileTiming implements Timing {\n    private locker: Locker = {}\n\n    constructor(private readonly filepath: string) {\n        const dir = path.dirname(this.filepath);\n\n        // ディレクトリが存在しない場合は作成\n        if (!fs.existsSync(dir)) {\n            fs.mkdirSync(dir, { recursive: true });\n        }\n\n        // ファイルが存在しない場合は作成\n        if (!fs.existsSync(this.filepath)) {\n            this.flush()\n            return\n        }\n\n        this.read()\n    }\n\n    private read() {\n        this.locker = JSON.parse(fs.readFileSync(this.filepath, 'utf-8'))\n    }\n\n    private flush() {\n        fs.writeFileSync(this.filepath, JSON.stringify(this.locker), 'utf-8')\n    }\n\n    async allow({\n        key,\n        date,\n    }: {\n        key: string,\n        date: Date,\n    }) {\n        if (this.locker[key] === undefined) {\n            return true\n        }\n\n        const nextTime = new Date(this.locker[key])\n\n        return date >= nextTime\n    }\n\n    async complete({\n        key,\n        constraint,\n        date,\n    }: {\n        key: string,\n        constraint: TimeConstraint,\n        date: Date,\n    }) {\n        this.locker[key] = constraint.next(date).toISOString()\n        this.flush()\n    }\n}\n\n","import { TimeConstraint, Timing } from \"@/timing/contract\";\nimport { Redis } from \"ioredis\";\n\ntype RedisTimingInput = {\n    host: string, port: number, keyPrefix?: string\n}\n\nexport const withRedisTiming = async (input: RedisTimingInput, f: (timing: RedisTiming) => Promise<void>) => {\n    const timing = new RedisTiming(input)\n\n    try {\n        await f(timing)\n    } finally {\n        await timing.terminate()\n    }\n}\n\nexport class RedisTiming implements Timing {\n    private client\n\n    constructor({ host, port, keyPrefix }: RedisTimingInput) {\n        this.client = new Redis({\n            host,\n            port,\n            keyPrefix\n        })\n    }\n\n    async allow({\n        key,\n        date,\n    }: { key: string, date: Date; }) {\n        // TTLで勝手に消えるのでkeyで取得できたらfalse, なかったらtrue\n        const result = await this.client.exists(key)\n        return result === 0\n    }\n\n    async complete({\n        key,\n        constraint,\n        date,\n    }: { key: string, constraint: TimeConstraint, date: Date; }) {\n        const next = constraint.next(date).getTime()\n        const ttl = Math.floor((next - date.getTime()) / 1000); // TTLを秒単位で計算\n\n        // nextまでの時間をTTLとしてredisに保存する\n        // keyはkeyでvalueはなくてもいい\n        if (ttl > 0) {\n            await this.client.set(key, '', 'EX', ttl); // TTLを設定してキーを保存\n        }\n    }\n\n    async terminate() {\n        await this.client.quit()\n    }\n}\n","\nimport { TimeConstraint } from \"@/timing/contract\"\nimport { AtLeastOne } from \"@/util/types\"\n\nexport class Rate implements TimeConstraint {\n    constructor(private readonly param: AtLeastOne<{\n        h: number,\n        m: number,\n    }>) { }\n\n    next(date: Date): Date {\n        const h_ms = (this.param.h || 0) * 60 * 60 * 1000\n        const m_ms = (this.param.m || 0) * 60 * 1000\n        const timestamp = date.getTime()\n\n        return new Date(timestamp + h_ms + m_ms)\n    }\n}\n\nexport class Daily implements TimeConstraint {\n    constructor(private readonly param: {\n        h: number,\n        m: number,\n    }) { }\n\n    next(date: Date): Date {\n        const base = new Date(\n            Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), this.param.h, this.param.m)\n        )\n\n        return date <= base\n            ? base\n            : (() => {\n                base.setDate(base.getDate() + 1)\n                return base\n            })()\n    }\n}\n"],"mappings":"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","names":["h","m","s"]}